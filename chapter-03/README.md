## chapter 03 코드에서 나는 악취

목표: 리팩터링을 ‘**언제**’ 진행해야 하는지 시점을 알기 위함.

내용: 리팩터링이 필요한 시점을 감지하는 **센서가이드**

### 3.1 기이한 이름 (공통형)

- 이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 두 가지 중 하나
- 해결 방법
  - 함수 선언 바꾸기(6.5)
  - 변수 이름 바꾸기(6.7)
  - 필드 이름 바꾸기(9.2)

### 3.2 중복 코드 (공통형)

- 해결 방법
  - 함수 추출하기(6.1)
  - 문장 슬라이드하기(8.6)
  - 메서드 올리기(12.1)

### 3.3 긴 함수 (공통형)

- 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드가 얼마나  일치하는가
- 해결 방법
  - 함수 추출하기(6.1): 함수를 짧게 만들기
  - 임시 변수를 질의 함수로 바꾸기(7.4): 임시 변수의 수를 줄이기
  - 매개변수 객체 만들기(6.8): 매개변수 수를 줄이기 1
  - 객체 통째로 넘기기(11.4): 매개변수 수를 줄이기 2
  - 함수를 명령으로 바꾸기(11.9): 리팩터링을 적용해도 임시 변수와 매개변수가 너무 많은 경우
- 추출할 코드 덩어리를 구분하는 방법
  - 주석이 있는 위치를 확인 (분리해야 할 경우가 많음)
  - 조건문 분해하기(10.1)
  - 함수 추출하기(6.1): switch문을 구성하는 case문을 변경
  - 조건문을 다형성으로 바꾸기(10.4): switch문이 여러개인 경우
  - 반복문 쪼개기(8.7): 반복문을 추출하여 독립 함수로 만들기

### 3.4 긴 매개변수 목록 (공통형)

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많음
- 해결 방법
  - 매개변수를 질의 함수로 바꾸기(11.5): 다른 매개변수에서 값을 얻어오는 경우
  - 객체 통째로 넘기기(11.4): 사용 중인 데이터 구조에서 값들을 뽑아 별개의 매개변수로 전달할 경우
  - 매개변수 객체 만들기(6.8): 항상 함께 전달되는 매개변수들이 있는 경우
  - 플래그 인수 제거하기(11.3): 플래그 역할의 매개변수가 있는 경우
  - 여러 함수를 클래스로 묶기(6.9): 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때

### 3.5 전역 데이터 (공통형)

- 해결 방법 (절대 있어서는 안되는 일이지만 혹시 있다면)
  - 변수 캡슐화하기(6.6)

### 3.6 가변 데이터 (공통형)

- 해결 방법
  - 변수 캡슐화하기(6.6): 정해놓은 함수를 거쳐야만 값을 수정
  - 변수 쪼개기(9.1): 용도별로 독립 변수에 저장
    - 문장 슬라이드하기(8.6)
    - 함수 추출하기(6.1)
  - 질의 함수와 변경 함수 분리하기(11.1): API 제작시 부작용 제거
    - 세터 제거하기(11.7)
  - 파생 변수를 질의 함수로 바꾸기(9.3)
  - 여러 함수를 클래스로 묶기(6.9): 변수의 유효범위를 제한
  - 여러 함수를 변환 함수로 묶기(6.10): 변수의 유효범위를 제한
  - 참조를 값으로 바꾸기(9.4)

### 3.7 뒤엉킨 변경 (공통형)

- 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 경우 생기는 문제
- 맥락을 분리시킨다
- 해결 방법
  - 단계 쪼개기(6.11)
  - 함수 옮기기(8.1)
  - 함수 추출하기(6.1)
  - 클래스 추출하기(7.5)

### 3.8 산탄총 수술 (객체형)

- 뒤엉킨 변경과 비슷하면서도 정반대
- 맥락별로 모은다
- 해결 방법
  - 함수 옮기기(8.1)
  - 필드 옮기기(8.2)
  - 여러 함수를 클래스로 묶기(6.9)
  - 여러 함수를 변환 함수로 묶기(6.10)
  - 단계 쪼개기(6.11)
  - 함수 인라인하기(6.2)
  - 클래스 인라인하기(7.6)

### 3.9 기능 편애 (객체형)

- 해결 방법
  - 함수 옮기기(8.1)
  - 함수 추출하기(6.1)

### 3.10 데이터 뭉치 (객체형)

- 해결 방법
  - 클래스 추출하기(7.5)
  - 매개변수 객체 만들기(6.8)
  - 객체 통째로 넘기기(11.4)

### 3.11 기본형 집착 (공통형)

- 해결 방법
  - 기본형을 객체로 바꾸기(7.5)
  - 타입 코드를 서브클래스로 바꾸기(12.6)
  - 조건부 로직을 다형성으로 바꾸기(10.4)
  - 클래스 추출하기(7.5)
  - 매개변수 객체 만들기(6.8)

### 3.12 반복되는 switch문 (공통형)

- 중복된 switch문
  - 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 함
  - 다형성을 사용하자(세련된 대체 기능)

- 해결 방법
  - 조건부 로직을 다형성으로 바꾸기(10.4)

- 다형성

### 3.13 반복문 (공통형)

- 해결 방법
  - 일급 함수를 이용하여 반복문을 파이프라인으로 바꾸기

### 3.14 성의 없는 요소 (공통형)

- 해결 방법 
  - 함수 인라인 하기(6.2)
  - 클래스 인라인 하기(7.6)
  - 계층 합치기(12.9): 상속인 경우
- 진배없다(그보다 못하거나 다를 것이 없다)

### 3.15 추측성 일반화 (공통형)

- ‘나중에 필요할 거야’라는 생각으로 필요 없는 코드를 작성하는 것
- 해결 방법
  - 계층 합치기(12.9): 추상 클래스
  - 함수 인라인 하기(6.2), 클래스 인라인 하기(7.6): 쓸데없이 위임하는 코드
  - 함수 선언 바꾸기(6.5): 본문에서 사용 되지 않는 매개변수
  - 죽은 코드 제거하기(8.9): 사용하는 곳이 없는 함수나 클래스

### 3.16 임시 필드 (객체형)

- 특정 상황에서 값이 설정되는 필드를 가진 클래스
- 수정 방법 (순서)
  1. 클래스 추출하기(7.5)
  2. 함수 옮기기(8.1)
  3. 특이 케이스 추가하기(10.5)

### 3.17 메시지 체인 (객체형)

- 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
  - ex) const managerName = aPerson.department.managerName;
- 해결 방법
  - 위임 숨기기(7.7)
  - 함수 추출하기(6.1)
  - 함수 옮기기(8.1)

### 3.18 중개자 (객체형)

- 객체의 대표적인 기능으로 세부사항을 숨겨주는 캡슐화가 있다
- 그러나 클래스가 제공하는 메서드 중 절반이 다른 클래스에게 구현을 위임한다면 문제가 된다
- 해결 방법
  - 중개자 제거하기(7.8)
  - 함수 인라인하기(6.2)

### 3.19 내부자 거래 (객체형)

- 모듈(객체) 사이의 데이터 거래가 많아지는 문제(결합도 - coupling)
- 해결 방법
  - 데이터를 주고 받는 모듈 분리하기
    - 함수 옮기기(8.1)
    - 필드 옮기기(8.2)
  - 상속 구조(부모-자식) 분리하기
    - 서브클래스를 위임으로 바꾸기(12.10)
    - 슈퍼클래스를 위임으로 바꾸기(12.11)
- 결합도

### 3.20 거대한 클래스 (객체형)

- 해결 방법
  - 클래스 추출하기(7.5)
  - 슈퍼클래스 추출하기(12.8)
  - 타입 코드를 서브클래스로 바꾸기(12.6)

### 3.21 서로 다른 인터페이스의 대안 클래스들 (객체형)

- 해결 방법
  - 함수 선언 바꾸기(6.5)
  - 함수 옮기기(8.1)
  - 슈퍼클래스 추출하기(12.8)

### 3.22 데이터 클래스 (객체형)

- 데이터 클래스? - 데이터 필드와 게터/세터 메서드로만 구성된 클래스
- 해결 방법
  - 레코드 캡슐화하기(7.1): 공개 필드 숨기기
  - 세터 제거하기(11.7): 변경하면 안 되는 필드
  - 함수 옮기기(8.1): 메서드를 데이터 클래스로 옮기기
  - 함수 추출하기(6.1): 함수 옮기기가 안된다면 옮길수 있는 부분을 별도 메서드로 추출
  - 단계 쪼개기(6.11): 중간 데이터 구조(불변)

### 3.23 상속 포기 (객체형)

- 해결 방법
  - 잘못된 계층구조 설계 (차악 방법)
    - 메서드 내리기(12.4)
    - 필드 내리기(12.5)
  - 부모의 인터페이스를 따르지 않을 때
    - 서브클래스를 위임으로 바꾸기(12.10)
    - 슈퍼클래스를 위임으로 바꾸기(12.11)

### 3.24 주석 (공통형)

- 주석은 향기를 입힌다, 그러나 주석을 탈취제처럼 사용하면 안된다
- 해결 방법
  - 함수 추출하기(6.1): 특정 블록이 하는 일에 주석을 남기고 싶을 때
  - 함수 선언 바꾸기(6.5): 이미 추출된 함수에 설명이 필요할 때
  - 어서션 추가하기(10.6): 시스템이 동작하기 위한 선행조건을 명시하고 싶을 때
- 주석이 필요하다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링 해본다.
- 권장 주석
  - 무엇을 해야할 지 모를 때 주석을 남기는 것을 권장한다.
  - 현재 진행상황이나 확실하지 않은 부분에 주석을 남긴다.
